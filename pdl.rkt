#!/usr/bin/env racket
#lang racket/base

(require racket/cmdline racket/dict racket/file racket/list racket/string)

(define-syntax-rule (def b ...) (define b ...))
(def : list) (def :* list*) (def :^ car) (def :> cdr)
(def :1 second) (def :2 third) (def :3 fourth) (def :4 fifth) (def :5 sixth) (def :6 seventh) (def :7 eighth) (def :8 ninth) (def :9 tenth)
(def str string-append)
(define-syntax-rule (@ b ...) (lambda b ...))
(define-syntax-rule (=: k v b ...) (let ((k v)) b ...))
; use custom destructuring macro b/c importing racket/match slows startup time
(define-syntax-rule (mlet2 k1 k2 v b ...) (let ((t v)) (let ((k1 (:^ t)) (k2 (:1 t))) b ...)))

(struct A (v t) #:transparent) ; atom (value S/I4/Op)
(struct CF (k p t))            ; c-fn (key param-types ret-type)
(struct F (k (p #:mutable) e)) ; fn (c-key params expr)
(struct G (f p) #:transparent) ; fn-call (fn args)
(struct E (v (t #:mutable)) #:transparent) ; expr (value type)
(def (T t) (E t t))
(struct C (k c t))             ; c-code (key code type)

(def (nonsense! . s) (displayln (string-join (:* "Nonsense! " s) "")) (exit 0))
(def (whitespace? c) (or (char=? c #\space) (char=? c #\tab) (char=? c #\return) (char=? c #\newline)))
(def cmd (command-line #:args args args))
(def ast
  (=: s (str (file->string (:^ cmd)) "\x29")
  (mlet2 v j
    (let read-list ((i 0))
      (if (= i (string-length s))
        (nonsense! "Too few \x29s")
        (=: c (string-ref s i)
          (cond ((whitespace? c) (read-list (+ i 1)))
                ((char=? c #\u28) (mlet2 v j (read-list (+ i 1))
                                  (mlet2 w k (read-list j)
                                    (: (:* v w) k))))
                ((char=? c #\u29) (: '() (+ i 1)))
                (else (mlet2 v j
                        (let read-sym ((i i))
                          (if (= i (string-length s))
                            (: "" i)
                            (=: c (string-ref s i)
                              (if (or (whitespace? c) (char=? c #\u28) (char=? c #\u29))
                                (: "" i)
                                (mlet2 v j (read-sym (+ i 1))
                                  (: (str (string c) v) j))))))
                      (mlet2 w k (read-list j)
                        (: (:* v w) k))))))))
    (if (= j (string-length s)) v (nonsense! "Too many \x29s")))))
(def uniq-cnt -1)
(def (uniq)
  (set! uniq-cnt (+ uniq-cnt 1))
  (str "_u_" (list->string
    (let uniq-gen ((i uniq-cnt))
      (:* (integer->char (=: r (remainder i 63)
            (+ r (cond ((< r 10) 48) ((< r 36) 55) ((< r 62) 61) (else 33)))))
          (if (< i 63) '() (uniq-gen (- (quotient i 63) 1))))))))
(def (op s) (:* s (T (A (string->symbol s) 'Op))))
(def c-fns '()) (def fns '())
(def env (:* (:* (op "?") (map (@(i)
  (unless (and (pair? i) (= (length i) 2)) (nonsense! "Top-level expressions must be of form (key value)"))
  (:* (:^ i) (let c2e ((c (:1 i))) (cond
    ((string? c) (if (string->number c) (T (A c 'I4)) (E (A c 'S) #f)))
    ((pair? c) (case (:^ c)
      (("c_fn") (=: f (CF (:1 c) (map c2e (:2 c)) (c2e (:3 c))) (set! c-fns (:* f c-fns)) (T f)))
      (("@") (=: f (F (uniq) (map (@(j) (:* (:^ j) (c2e (:1 j)))) (:1 c)) (c2e (:2 c))) (set! fns (:* f fns)) (T f)))
      (else (E (G (c2e (:^ c)) (map c2e (:> c))) #f))))
    (else (error "Bad token node (should never happen)")))))) ast)) #f))
(for ((i fns)) (set-F-p! i (:* (F-p i) env)))
(def (name e) (=: v (E-v e) (cond
  ((A? v) (string (A-v v)))
  ((CF? v) (str "C function " (CF-k v)))
  ((F? v) "Anonymous function")
  ((G? v) (name (type v)))
  (else (error "Name fn doesn't recognize value (should never happen)")))))
(def (expr p e) (if (and (A? (E-v e)) (eq? (A-t (E-v e)) 'S))
  (=: s (A-v (E-v e)) (if p (or (dict-ref (:^ p) s #f) (expr (:> p) e)) (nonsense! "\"" s "\" not defined"))) e))
(def (type p e) (or (E-t e) (=: e2 (expr p e) (set-E-t! e (or (E-t e2) (begin (set-E-t! e2 (=: g (E-v e2)
  (unless (G? g) (error "Non-fn call node isn't typed (should never happen)"))
  (=: f (type p (G-f g)) (if (and (A? f) (eq? (A-t f) 'Op) (eq? (A-v f) '?))
    (if (= (length (G-p g)) 3) (=: a (type p (:1 (G-p g))) (=: b (type p (:2 (G-p g)))
                               a #|(if (equal? a b) a (nonsense! "Then types " (name a) " and " (name b) " don't match"))|#)) ; TODO: name won't work here
                             (nonsense! "? takes 3 arguments but you gave it " (number->string (length (G-p g)))))
    (mlet2 fp ft (cond ((CF? f) (: (CF-p f) (CF-t f)))
                       ((F? f) (: (map :> (:^ (F-p f))) (F-e f)))
                       (else (nonsense! (name f) " is not a function")))
      (unless (= (length (G-p g)) (length fp))
        (nonsense! (name (G-f g)) " takes " (number->string (length fp)) " arguments but you gave it " (number->string (length (G-p g)))))
      ; in future, will need "is" to compare parameterized types
      ;(for ((i (G-p g)) (j fp) (n (in-range (length fp)))) (unless (equal? (type p i) (type env j)) (nonsense! "Parameter type mismatch")))
      (type env ft)))))) (E-t e2)))) (E-t e))))
(def (gen-t t) (cond
  ((A? t) (case (A-t t) ((I4) "int32_t") (else (error "TODO: gen-t" (symbol->string (A-t t))))))
  (else (error "TODO"))))
(def (gen-e k p e) (=: t (type p e) (C k
  (=: v (E-v e) (cond
    ((and (A? v) (not (eq? (A-t v) 'Op))) (str k "=" (A-v v) ";"))
    ((G? v) (=: f (type p (G-f v)) (if (and (A? f) (eq? (A-t f) 'Op) (eq? (A-v f) '?))
      (let* ((a (uniq)) (b (gen-e a p (:^ (G-p v)))) (c (gen-e k p (:1 (G-p v)))) (d (gen-e k p (:2 (G-p v)))))
        (str "{" (C-t b) " " a ";" (C-c b) "if(" a ")" (C-c c) "else " (C-c d) "}"))
      (=: a (map (@(i) (gen-e (uniq) p i)) (G-p v))
        (str "{" (string-join (map (@(i) (str (C-t i) " " (C-k i) ";" (C-c i))) a) "")
             k "=" (cond ((CF? f) (CF-k f)) ((F? f) (F-k f))) "(" (string-join (map C-k a) ",") ");}")))))))
  (gen-t t))))
(def (gen-f f) (str (gen-t (type (F-p f) (F-e f))) " " (F-k f) "("
                    (if (null? (:^ (F-p f))) "void" (string-join (map (@(i) (str (gen-t (type env (:> i))) " " (:^ i))) (:^ (F-p f))) ",")) ")"))
(def fout (str (:^ cmd) ".c"))
(when (file-exists? fout) (delete-file fout))
(display-to-file (str (file->string "pdl.h")
  (string-join (map (@(i) (str (gen-f i) ";\n")) fns) "")
  (string-join (map (@(i) (=: a (gen-e (uniq) (F-p i) (F-e i)) (str (gen-f i) "{" (C-t a) " " (C-k a) ";" (C-c a) "return " (C-k a) ";}\n"))) fns) "")) fout)
